use std::fmt::{Debug, Display};

use serde::{de::IntoDeserializer, Deserialize, Deserializer, Serialize, Serializer};
use serde_json::{Map, Value};

use super::identifier::AcmeIdentifier;

/// ACME Problem document
/// https://datatracker.ietf.org/doc/html/rfc8555#section-6.7
/// Based on RFC 7807 "problem detail":
/// https://datatracker.ietf.org/doc/html/rfc7807
#[derive(Serialize, Deserialize, Debug, Default, Clone)]
#[serde(default)]
pub struct AcmeProblem {
    /// A URI reference [RFC3986] that identifies the problem type.
    #[serde(
        rename = "type",
        skip_serializing_if = "Option::is_none",
        serialize_with = "serialize_problem_type",
        deserialize_with = "deserialize_problem_type"
    )]
    pub type_: Option<AcmeProblemType>,

    /// A short, human-readable summary of the problem type.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    /// The HTTP status code ([RFC7231], Section 6) generated by the origin
    /// server for this occurrence of the problem.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<u16>,

    /// A human-readable explanation specific to this occurrence of the problem.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// A URI reference that identifies the specific occurrence of the problem.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,

    /// [...] an ACME problem document MAY contain the "subproblems" field,
    /// containing a JSON array of problem documents [...]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub subproblems: Vec<AcmeProblem>,

    /// ACME clients may choose to use the "identifier" field of a subproblem as
    /// a hint that an operation would succeed if that identifier were omitted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub identifier: Option<AcmeIdentifier>,

    /// Extension members: Problem type definitions MAY extend the problem
    /// details object with additional members.
    #[serde(flatten)]
    pub extensions: Map<String, Value>,
}

impl AcmeProblem {
    pub const CONTENT_TYPE: &'static str = "application/problem+json";

    pub fn has_type(&self, problem_type: AcmeProblemType) -> bool {
        self.type_ == Some(problem_type)
    }
}

impl Display for AcmeProblem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.type_.is_some() && self.detail.is_some() {
            write!(
                f,
                "{:?}: {:?}",
                self.type_.as_ref().unwrap(),
                self.detail.as_ref().unwrap()
            )
        } else {
            write!(f, "{:?}", self)
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum AcmeProblemType {
    /// The request specified an account that does not exist
    #[serde(rename = "urn:ietf:params:acme:error:accountDoesNotExist")]
    AccountDoesNotExist,

    /// The request specified a certificate to be revoked that has already been revoked
    #[serde(rename = "urn:ietf:params:acme:error:alreadyRevoked")]
    AlreadyRevoked,

    /// The CSR is unacceptable (e.g., due to a short key)
    #[serde(rename = "urn:ietf:params:acme:error:badCSR")]
    BadCSR,

    /// The client sent an unacceptable anti-replay nonce
    #[serde(rename = "urn:ietf:params:acme:error:badNonce")]
    BadNonce,

    /// The JWS was signed by a public key the server does not support
    #[serde(rename = "urn:ietf:params:acme:error:badPublicKey")]
    BadPublicKey,

    /// The revocation reason provided is not allowed by the server
    #[serde(rename = "urn:ietf:params:acme:error:badRevocationReason")]
    BadRevocationReason,

    /// The JWS was signed with an algorithm the server does not support
    #[serde(rename = "urn:ietf:params:acme:error:badSignatureAlgorithm")]
    BadSignatureAlgorithm,

    /// Certification Authority Authorization (CAA) records forbid the CA from issuing a certificate                  
    #[serde(rename = "urn:ietf:params:acme:error:caa")]
    Caa,

    /// Specific error conditions are indicated in the "subproblems" array             
    #[serde(rename = "urn:ietf:params:acme:error:compound")]
    Compound,

    /// The server could not connect to validation target                       
    #[serde(rename = "urn:ietf:params:acme:error:connection")]
    Connection,

    /// There was a problem with a DNS query during identifier validation            
    #[serde(rename = "urn:ietf:params:acme:error:dns")]
    Dns,

    /// The request must include a value for the "externalAccountBinding" field      
    #[serde(rename = "urn:ietf:params:acme:error:externalAccountRequired")]
    ExternalAccountRequired,

    /// Response received didn't match the challenge's requirements                
    #[serde(rename = "urn:ietf:params:acme:error:incorrectResponse")]
    IncorrectResponse,

    /// A contact URL for an account was invalid
    #[serde(rename = "urn:ietf:params:acme:error:invalidContact")]
    InvalidContact,

    /// The request message was malformed
    #[serde(rename = "urn:ietf:params:acme:error:malformed")]
    Malformed,

    /// The request attempted to finalize an order that is not ready to be finalized
    #[serde(rename = "urn:ietf:params:acme:error:orderNotReady")]
    OrderNotReady,

    /// The request exceeds a rate limit
    #[serde(rename = "urn:ietf:params:acme:error:rateLimited")]
    RateLimited,

    /// The server will not issue certificates for the identifier                      
    #[serde(rename = "urn:ietf:params:acme:error:rejectedIdentifier")]
    RejectedIdentifier,

    /// The server experienced an internal error
    #[serde(rename = "urn:ietf:params:acme:error:serverInternal")]
    ServerInternal,

    /// The server received a TLS error during validation
    #[serde(rename = "urn:ietf:params:acme:error:tls")]
    Tls,

    /// The client lacks sufficient authorization                           
    #[serde(rename = "urn:ietf:params:acme:error:unauthorized")]
    Unauthorized,

    /// A contact URL for an account used an unsupported protocol scheme             
    #[serde(rename = "urn:ietf:params:acme:error:unsupportedContact")]
    UnsupportedContact,

    /// An identifier is of an unsupported type
    #[serde(rename = "urn:ietf:params:acme:error:unsupportedIdentifier")]
    UnsupportedIdentifier,

    /// Visit the "instance" URL and take actions specified there                 
    #[serde(rename = "urn:ietf:params:acme:error:userActionRequired")]
    UserActionRequired,

    #[serde(skip_deserializing)]
    Other(String),
}

// Workaround for https://github.com/serde-rs/serde/issues/912
fn serialize_problem_type<S>(
    value: &Option<AcmeProblemType>,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    match value {
        Some(AcmeProblemType::Other(other)) => other.serialize(serializer),
        Some(value) => value.serialize(serializer),
        _ => panic!("cannot serialize None"),
    }
}

// Workaround for https://github.com/serde-rs/serde/issues/912
fn deserialize_problem_type<'de, D>(deserializer: D) -> Result<Option<AcmeProblemType>, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    Ok(Some(
        AcmeProblemType::deserialize(IntoDeserializer::<'de, D::Error>::into_deserializer(
            s.as_str(),
        ))
        .unwrap_or(AcmeProblemType::Other(s)),
    ))
}

#[cfg(test)]
mod tests {
    use serde_json::json;

    use super::*;

    #[test]
    fn rfc8555_problem_example() {
        let problem = AcmeProblem::deserialize(json!({
            "type": "urn:ietf:params:acme:error:malformed",
            "detail": "Some of the identifiers requested were rejected",
            "subproblems": [
            {
                "type": "urn:ietf:params:acme:error:malformed",
                "detail": "Invalid underscore in DNS name \"_example.org\"",
                "identifier": {
                    "type": "dns",
                    "value": "_example.org"
                }
            },
            {
                "type": "urn:ietf:params:acme:error:rejectedIdentifier",
                "detail": "This CA will not issue for \"example.net\"",
                "identifier": {
                    "type": "dns",
                    "value": "example.net"
                }
            }]
        }))
        .unwrap();

        assert_eq!(problem.type_.unwrap(), AcmeProblemType::Malformed);
        assert_eq!(
            problem.detail.unwrap(),
            "Some of the identifiers requested were rejected"
        );
        assert_eq!(problem.subproblems.len(), 2);

        let subproblem = problem.subproblems[1].clone();
        assert!(subproblem.has_type(AcmeProblemType::RejectedIdentifier));
        assert_eq!(
            subproblem.identifier.unwrap(),
            AcmeIdentifier::dns("example.net")
        );
    }
}
